#!/usr/bin/env python

import gevent.monkey
gevent.monkey.patch_all()

from collections import defaultdict
import httplib
import logging
from optparse import OptionParser
import re
import sys

import bottle
import grequests
import image_merge
import requests

from tilecloud import Tile
from tilecloud.grid.free import FreeTileGrid
from tilecloud.layout.template import TemplateTileLayout


scale = 2
resolutions = [int(scale * x) for x in [4000,3750,3500,3250,3000,2750,2500,2250,2000,1750,1500,1250,1000,750,650,500,250,100,50,20,10,5,2.5,2,1.5,1]]
max_extent = (420000, 30000, 900000, 350000)
tile_size = 256
tilegrid = FreeTileGrid(resolutions, max_extent, tile_size, scale)

session = requests.session()

tilelayouts = {}
tilelayouts['VelolandRoutenNational'] = TemplateTileLayout('http://schweizmobil-test.s3.amazonaws.com/tpayne/VelolandRoutenNational/%(z)d/%(x)d/%(y)d.png')
tilelayouts['VelolandRoutenRegional'] = TemplateTileLayout('http://schweizmobil-test.s3.amazonaws.com/tpayne/VelolandRoutenRegional/%(z)d/%(x)d/%(y)d.png')
tilelayouts['VelolandRoutenLokal'] = TemplateTileLayout('http://schweizmobil-test.s3.amazonaws.com/tpayne/VelolandRoutenLokal/%(z)d/%(x)d/%(y)d.png')

options = None
urlcache = {}  # FIXME use memcache
imagecache = defaultdict(dict)  # FIXME use memcache


@bottle.route('/tilecache')
def tilecache():

    if False:
        if bottle.request.GET.get('EXCEPTIONS') != 'application/vnd.se_inimage':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('FORMAT') != 'image/png':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('REQUEST') != 'GetMap':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('SERVICE') != 'WMS':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('SRS') != 'EPSG:21781':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('STYLES') != '':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('VERSION') != '1.1.1':
            bottle.abort(httplib.BAD_REQUEST)

    layers = bottle.request.GET.get('LAYERS')
    if layers is None:
        bottle.abort(httplib.BAD_REQUEST)

    bbox = bottle.request.GET.get('bbox')
    if bbox is None:
        bottle.abort(httplib.BAD_REQUEST)
    m = re.match(r'(\d+),(\d+),(\d+),(\d+)\Z', bbox)
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    bbox = map(int, m.groups())

    width = bottle.request.GET.get('WIDTH')
    if width is None:
        bottle.abort(httplib.BAD_REQUEST)
    m = re.match(r'(\d+)\Z', width)
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    width = int(m.group(1))
    if width != tile_size:
        bottle.abort(httplib.BAD_REQUEST)

    height = bottle.request.GET.get('HEIGHT')
    if height is None:
        bottle.abort(httplib.BAD_REQUEST)
    m = re.match(r'(\d+)\Z', height)
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    height = int(m.group(1))
    if height != tile_size:
        bottle.abort(httplib.BAD_REQUEST)

    resolution = (bbox[2] - bbox[0]) / width
    if resolution != (bbox[3] - bbox[1]) / height:
        bottle.abort(httplib.BAD_REQUEST)
    if scale * resolution not in resolutions:
        bottle.abort(httplib.BAD_REQUEST)

    z = resolutions.index(scale * resolution)
    x = bbox[0]
    y = bbox[1]
    tilecoord = tilegrid.tilecoord(z, x, y)

    if tilecoord in imagecache[layers]:
        image = imagecache[layers][tilecoord]
    else:
        urls = []
        for layer in layers.split(','):
            if layer not in tilelayouts:
                bottle.abort(httplib.BAD_REQUEST)
            tilelayout = tilelayouts[layer]
            urls.append(tilelayout.filename(tilecoord))
        requests = [grequests.get(url, session=session) for url in urls if url not in urlcache]
        if requests:
            for response in grequests.map(requests, size=len(requests)):
                if response.status_code == 200:
                    tile = Tile(tilecoord, data=response.content)
                elif response.status_code == 403:
                    tile = Tile(tilecoord, error=response.status_code)
                urlcache[response.url] = tile
        tiles = [urlcache[url] for url in urls]
        images = [tile.data for tile in tiles if tile.error is None]
        if not images:
            bottle.abort(httplib.NO_CONTENT)
        image = image_merge.merge(images, preserve_colors=options.preserve_colors)
        imagecache[layers][tilecoord] = image

    bottle.response.content_type = 'image/png'
    bottle.response.set_header('Access-Control-Allow-Methods', 'GET')
    bottle.response.set_header('Access-Control-Allow-Origin', '*')
    return image


def main(argv):

    global options

    option_parser = OptionParser()
    option_parser.add_option('--host', default='127.0.0.1', metavar='HOST')
    option_parser.add_option('--port', default=8080, metavar='PORT', type=int)
    option_parser.add_option('--preserve-colors', action='store_true', default=False)
    option_parser.add_option('--quiet', action='store_true', default=False)
    option_parser.add_option('--log-filename', metavar='FILENAME')
    option_parser.add_option('--log-format', default='%(asctime)s %(module)s %(message)s', metavar='FORMAT')
    option_parser.add_option('--log-level', default=0, metavar='LEVEL', type=int)
    option_parser.add_option('--verbose', '-v', action='count', dest='log_level')
    options, args = option_parser.parse_args(argv[1:])

    logging.basicConfig(filename=options.log_filename, format=options.log_format, level=logging.WARN - 10 * options.log_level)

    bottle.run(host=options.host, port=options.port, quiet=options.quiet, server='gevent')


if __name__ == '__main__':
    sys.exit(main(sys.argv))
