#!/usr/bin/env python

import gevent.monkey
gevent.monkey.patch_all()

from collections import defaultdict
import httplib
import logging
from optparse import OptionParser
import re
import sys

import gevent
import gevent.event
import image_merge
import bottle

from tilecloud import Tile
from tilecloud.grid.free import FreeTileGrid
from tilecloud.layout.template import TemplateTileLayout
from tilecloud.store.url import URLTileStore


option_parser = OptionParser()
option_parser.add_option('--debug', action='store_true', default=True)
option_parser.add_option('--host', default='127.0.0.1', metavar='HOST')
option_parser.add_option('--port', default=8080, metavar='PORT', type=int)
option_parser.add_option('--preserve-colors', action='store_true', default=False)
option_parser.add_option('--quiet', action='store_true', default=False)
option_parser.add_option('--log-filename', metavar='FILENAME')
option_parser.add_option('--log-format', default='%(asctime)s %(module)s %(message)s', metavar='FORMAT')
option_parser.add_option('--log-level', default=0, metavar='LEVEL', type=int)
option_parser.add_option('--verbose', '-v', action='count', dest='log_level')
options, args = option_parser.parse_args(sys.argv[1:])

logging.basicConfig(filename=options.log_filename, format=options.log_format, level=logging.WARN - 10 * options.log_level)

resolutions = [650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1]  # FIXME check 2.5
max_extent = (420000, 30000, 900000, 350000)  # FIXME
tile_size = 256
tilegrid = FreeTileGrid(resolutions, max_extent, tile_size)

tilestores = {}
template = 'http://{z}/{x}/{y}.png'
tilestores['SkatinglandRoutenNational'] = URLTileStore((TemplateTileLayout(template),))

tilecache = defaultdict(dict)  # FIXME use memcache
imagecache = defaultdict(dict)  # FIXME use memcache


def async_get_one(layer, tilestore, tilecoord):
    def f():
        tile = tilestore.get_one(Tile(tilecoord))
        tilecache[layer][tilecoord] = tile
        return tile
    return f


@bottle.route('/tilecache')
def tilecache():

    if False:
        if bottle.request.GET.get('EXCEPTIONS') != 'application/vnd.se_inimage':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('FORMAT') != 'image/png':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('REQUEST') != 'GetMap':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('SERVICE') != 'WMS':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('SRS') != 'EPSG:21781':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('STYLES') != '':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('VERSION') != '1.1.1':
            bottle.abort(httplib.BAD_REQUEST)

    layers = bottle.request.GET.get('LAYERS')

    m = re.match(r'(\d+),(\d+),(\d+),(\d+)\Z', bottle.request.GET.get('bbox'))
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    bbox = map(int, m.groups())

    m = re.match(r'(\d+)\Z', bottle.request.GET.get('WIDTH'))
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    width = int(m.group(1))
    if width != tile_size:
        bottle.abort(httplib.BAD_REQUEST)

    m = re.match(r'(\d+)\Z', bottle.request.GET.get('HEIGHT'))
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    height = int(m.group(1))
    if height != tile_size:
        bottle.abort(httplib.BAD_REQUEST)

    resolution = (bbox[2] - bbox[0]) / width
    if resolution != (bbox[3] - bbox[1]) / height:
        bottle.abort(httplib.BAD_REQUEST)
    if resolution not in resolutions:
        bottle.abort(httplib.BAD_REQUEST)

    z = resolutions.index(resolution)
    x = bbox[0]
    y = bbox[1]
    tilecoord = tilegrid.tilecoord(z, x, y)

    if tilecoord in imagecache[layers]:
        image = imagecache[layers][tilecoord]
    else:
        results = []
        for layer in layers.split(','):
            if layer not in tilestores:
                bottle.about(httplib.BAD_REQUEST)
            result = gevent.event.AsyncResult()
            tilestore = tilestores[layer]
            if tilecoord in tilecache[layer]:
                result.set(tilecache[layer][tilecoord].data)
            else:
                gevent.spawn(async_get_one(layer, tilestore, tilecoord)).link(result)
        images = [result.get().data for result in results]
        image = image_merge.merge(images, preserve_colors=options.preserve_colors)
        imagecache[layers][tilecoord] = image

    bottle.response.content_type = 'image/png'
    bottle.response.set_header('Access-Control-Allow-Methods', 'GET')
    bottle.response.set_header('Access-Control-Allow-Origin', '*')
    return image


bottle.run(host=options.host, port=options.port, reloader=options.debug, quiet=options.quiet, server='gevent')
