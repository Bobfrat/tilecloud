#!/usr/bin/env python

import gevent.monkey
gevent.monkey.patch_all()

from collections import defaultdict
import httplib
import logging
from optparse import OptionParser
import re
import sys

import grequests
import image_merge
import bottle

from tilecloud.grid.free import FreeTileGrid
from tilecloud.layout.template import TemplateTileLayout


scale = 2
resolutions = [int(scale * x) for x in [650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1]]
max_extent = (420000, 30000, 900000, 350000)
tile_size = 256
tilegrid = FreeTileGrid(resolutions, max_extent, tile_size, scale)

tilelayouts = {}
tilelayouts['SkatinglandRoutenNational'] = TemplateTileLayout('http://a.tile.openstreetmap.org/%(z)d/%(x)d/%(y)d.png')
tilelayouts['SkatinglandRoutenRegional'] = TemplateTileLayout('http://b.tile.openstreetmap.org/%(z)d/%(x)d/%(y)d.png')
tilelayouts['SkatinglandRoutenLokal'] = TemplateTileLayout('http://c.tile.openstreetmap.org/%(z)d/%(x)d/%(y)d.png')

options = None
urlcache = {}  # FIXME use memcache
imagecache = defaultdict(dict)  # FIXME use memcache


@bottle.route('/tilecache')
def tilecache():

    if False:
        if bottle.request.GET.get('EXCEPTIONS') != 'application/vnd.se_inimage':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('FORMAT') != 'image/png':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('REQUEST') != 'GetMap':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('SERVICE') != 'WMS':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('SRS') != 'EPSG:21781':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('STYLES') != '':
            bottle.abort(httplib.BAD_REQUEST)
        if bottle.request.GET.get('VERSION') != '1.1.1':
            bottle.abort(httplib.BAD_REQUEST)

    layers = bottle.request.GET.get('LAYERS')
    if layers is None:
        bottle.abort(httplib.BAD_REQUEST)

    bbox = bottle.request.GET.get('bbox')
    if bbox is None:
        bottle.abort(httplib.BAD_REQUEST)
    m = re.match(r'(\d+),(\d+),(\d+),(\d+)\Z', bbox)
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    bbox = map(int, m.groups())

    width = bottle.request.GET.get('WIDTH')
    if width is None:
        bottle.abort(httplib.BAD_REQUEST)
    m = re.match(r'(\d+)\Z', width)
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    width = int(m.group(1))
    if width != tile_size:
        bottle.abort(httplib.BAD_REQUEST)

    height = bottle.request.GET.get('HEIGHT')
    if height is None:
        bottle.abort(httplib.BAD_REQUEST)
    m = re.match(r'(\d+)\Z', height)
    if not m:
        bottle.abort(httplib.BAD_REQUEST)
    height = int(m.group(1))
    if height != tile_size:
        bottle.abort(httplib.BAD_REQUEST)

    resolution = (bbox[2] - bbox[0]) / width
    if resolution != (bbox[3] - bbox[1]) / height:
        bottle.abort(httplib.BAD_REQUEST)
    if resolution not in resolutions:
        bottle.abort(httplib.BAD_REQUEST)

    z = resolutions.index(resolution)
    x = bbox[0]
    y = bbox[1]
    tilecoord = tilegrid.tilecoord(z, x, y)

    if tilecoord in imagecache[layers]:
        image = imagecache[layers][tilecoord]
    else:
        urls = []
        for layer in layers.split(','):
            if layer not in tilelayouts:
                bottle.abort(httplib.BAD_REQUEST)
            tilelayout = tilelayouts[layer]
            urls.append(tilelayout.filename(tilecoord))
        requests = [grequests.get(url) for url in urls if url not in urlcache]
        if requests:
            for response in grequests.imap(requests):
                urlcache[response.url] = response.content
        images = [urlcache[url] for url in urls]
        image = image_merge.merge(images, preserve_colors=options.preserve_colors)
        imagecache[layers][tilecoord] = image

    bottle.response.content_type = 'image/png'
    bottle.response.set_header('Access-Control-Allow-Methods', 'GET')
    bottle.response.set_header('Access-Control-Allow-Origin', '*')
    return image


def main(argv):

    global options

    option_parser = OptionParser()
    option_parser.add_option('--host', default='127.0.0.1', metavar='HOST')
    option_parser.add_option('--port', default=8080, metavar='PORT', type=int)
    option_parser.add_option('--preserve-colors', action='store_true', default=False)
    option_parser.add_option('--quiet', action='store_true', default=False)
    option_parser.add_option('--log-filename', metavar='FILENAME')
    option_parser.add_option('--log-format', default='%(asctime)s %(module)s %(message)s', metavar='FORMAT')
    option_parser.add_option('--log-level', default=0, metavar='LEVEL', type=int)
    option_parser.add_option('--verbose', '-v', action='count', dest='log_level')
    options, args = option_parser.parse_args(argv[1:])

    logging.basicConfig(filename=options.log_filename, format=options.log_format, level=logging.WARN - 10 * options.log_level)

    bottle.run(host=options.host, port=options.port, quiet=options.quiet, server='gevent')


if __name__ == '__main__':
    sys.exit(main(sys.argv))
