#!/usr/bin/env python

from itertools import imap
import logging
from optparse import OptionParser
import os.path
import sys

from tilecloud import BoundingPyramid, TileStore, consume
from tilecloud.filter.benchmark import Benchmark
from tilecloud.filter.consistenthash import EveryNth
from tilecloud.filter.error import DropErrors, LogErrors, MaximumConsecutiveErrors, MaximumErrorRate, MaximumErrors
from tilecloud.filter.logger import Logger
from tilecloud.filter.rate import RateLimit
from tilecloud.store.boundingpyramid import BoundingPyramidTileStore


def main(argv):
    logger = logging.getLogger(os.path.basename(argv[0]))
    option_parser = OptionParser()
    option_parser.add_option('--benchmark', action='store_true')
    option_parser.add_option('-b', '--bounding-pyramid', metavar='BOUNDING-PYRAMID')
    option_parser.add_option('-i', metavar='I', type=int)
    option_parser.add_option('-m', '--move', action='store_true')
    option_parser.add_option('--maximum-consecutive-errors', metavar='N', type=int)
    option_parser.add_option('--maximum-errors', metavar='N', type=int)
    option_parser.add_option('--maximum-error-rate', metavar='FLOAT', type=float)
    option_parser.add_option('-n', metavar='N', type=int)
    option_parser.add_option('-o', '--overwrite', action='store_true')
    option_parser.add_option('-r', '--rate-limit', metavar='HZ', type=float)
    option_parser.add_option('-v', '--verbose', action='store_true')
    options, args = option_parser.parse_args(argv[1:])
    if options.verbose:
        logging.basicConfig(level=logging.INFO)
    else:
        logging.basicConfig(level=logging.WARNING)
    assert len(args) >= 2
    if options.bounding_pyramid:
        bounding_pyramid = BoundingPyramid.from_string(options.bounding_pyramid)
    else:
        bounding_pyramid = None
    benchmark = Benchmark() if options.benchmark else None
    try:
        output_tile_store = TileStore.load(args[-1])
        for arg in args[:-1]:
            input_tile_store = TileStore.load(arg)
            if bounding_pyramid:
                tilestream = BoundingPyramidTileStore(bounding_pyramid).list()
            else:
                tilestream = input_tile_store.list()
            if options.i is not None and options.n is not None:
                tilestream = imap(EveryNth(options.n, options.i), tilestream)
            if not options.overwrite:
                tilestream = (tile for tile in tilestream if tile not in output_tile_store)
            if options.rate_limit:
                tilestream = imap(RateLimit(options.rate_limit), tilestream)
            if benchmark:
                tilestream = imap(benchmark.sample(), tilestream)
            tilestream = input_tile_store.get(tilestream)
            if benchmark:
                tilestream = imap(benchmark.sample('get'), tilestream)
            tilestream = imap(LogErrors(logger, logging.ERROR, '%(tilecoord)s: %(error)s'), tilestream)
            if options.maximum_consecutive_errors:
                tilestream = imap(MaximumConsecutiveErrors(options.maximum_consecutive_errors), tilestream)
            if options.maximum_error_rate:
                tilestream = imap(MaximumErrorRate(options.maximum_error_rate), tilestream)
            if options.maximum_errors:
                tilestream = imap(MaximumErrors(options.maximum_errors), tilestream)
            tilestream = imap(DropErrors(), tilestream)
            tilestream = output_tile_store.put(tilestream)
            if benchmark:
                tilestream = imap(benchmark.sample('put'), tilestream)
            if options.move:
                tilestream = input_tile_store.delete(tilestream)
                if benchmark:
                    tilestream = imap(benchmark.sample('delete'), tilestream)
            if options.verbose:
                tilestream = imap(Logger(logger, logging.INFO, '%(tilecoord)s'), tilestream)
            consume(tilestream, None)
    finally:
        logging.basicConfig(level=logging.INFO)
        if benchmark:
            for key in ('get', 'put', 'delete'):
                if key in benchmark.statisticss:
                    logger.info('%s: %s' % (key, benchmark.statisticss[key]))


if __name__ == '__main__':
    sys.exit(main(sys.argv))
